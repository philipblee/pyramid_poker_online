<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pyramid Poker Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        /* Animated background particles */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.3; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 0.8; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        .header h1 {
            font-size: 3.5rem;
            background: linear-gradient(45deg, #ffd700, #ff6b6b, #4ecdc4);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s ease-in-out infinite;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .version-tag {
            display: inline-block;
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid #4ecdc4;
            border-radius: 20px;
            padding: 4px 12px;
            font-size: 12px;
            color: #4ecdc4;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:disabled::before {
            display: none;
        }

        .sidebar-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            padding: 12px 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .sidebar-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 25px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .game-area.sidebar-hidden {
            grid-template-columns: 1fr;
        }

        .main-game {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .sidebar.hidden {
            display: none;
        }

        .hand-section {
            margin-bottom: 20px;
        }

        .hand-label {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #ffd700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hand-icon {
            font-size: 20px;
        }

        .hand-area {
            min-height: 110px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .hand-area.valid {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .hand-area.invalid {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        .hand-area.drop-target {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
            transform: scale(1.02);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
        }

        .staging-area {
            background: rgba(255, 215, 0, 0.08);
            border: 2px dashed #ffd700;
            min-height: 120px;
        }

        .staging-area:hover {
            background: rgba(255, 215, 0, 0.12);
        }

        .card {
            width: 68px;
            height: 95px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            user-select: none;
            line-height: 1.1;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: translateY(-8px) scale(1.08);
            box-shadow: 0 12px 25px rgba(0,0,0,0.4);
            z-index: 10;
        }

        .card:active {
            cursor: grabbing;
        }

        .card.dragging {
            opacity: 0.6;
            transform: rotate(8deg) scale(1.1);
            z-index: 1000;
        }

        .card.red {
            background: linear-gradient(135deg, #fff, #f8f8f8);
            color: #d32f2f;
        }

        .card.black {
            background: linear-gradient(135deg, #fff, #f8f8f8);
            color: #333;
        }

        .card.wild {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            border: 2px solid #ff6b6b;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9); }
        }

        .status {
            text-align: center;
            font-size: 17px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .player-list {
            margin-bottom: 20px;
        }

        .player-item {
            padding: 15px;
            margin-bottom: 12px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }

        .player-item.current {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        .player-item.ready {
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid #4ecdc4;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.3);
        }

        .hand-strength {
            font-size: 13px;
            color: #ccc;
            margin-top: 5px;
            opacity: 0.8;
        }

        .rules {
            margin-top: 25px;
            font-size: 14px;
            line-height: 1.7;
            opacity: 0.85;
        }

        .rules h3 {
            color: #ffd700;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .scoring-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: none;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }

        .scoring-content {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            margin: 20px auto;
            padding: 35px;
            border-radius: 25px;
            max-width: 1200px;
            color: white;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .close-popup {
            position: absolute;
            top: 20px;
            right: 25px;
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid #ff6b6b;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 50%;
            transition: all 0.3s ease;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-popup:hover {
            background: rgba(255, 107, 107, 0.4);
            transform: scale(1.1);
        }

        .player-hands-section {
            margin-bottom: 35px;
        }

        .player-hand-display {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .player-hand-display:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }

        .player-hand-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 18px;
            color: #ffd700;
        }

        .hand-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .hand-label-popup {
            width: 100px;
            font-weight: bold;
            color: #ffd700;
            flex-shrink: 0;
        }

        .hand-cards {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .card-mini {
            width: 38px;
            height: 52px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.3);
            line-height: 1;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .card-mini.red {
            background: linear-gradient(135deg, #fff, #f8f8f8);
            color: #d32f2f;
        }

        .card-mini.black {
            background: linear-gradient(135deg, #fff, #f8f8f8);
            color: #333;
        }

        .card-mini.wild {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            border: 1px solid #ff6b6b;
        }

        .hand-strength-popup {
            margin-left: 15px;
            color: #ccc;
            font-size: 14px;
        }

        .round-robin-section {
            margin-top: 35px;
        }

        .matchup {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 18px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .matchup:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .matchup-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #ffd700;
        }

        .comparison-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .comparison-row:last-child {
            border-bottom: none;
            font-weight: bold;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 2px solid rgba(255, 215, 0, 0.3);
        }

        .player-result {
            flex: 1;
            text-align: center;
        }

        .winner {
            color: #4ecdc4;
            font-weight: bold;
        }

        .loser {
            color: #ff6b6b;
        }

        .tie {
            color: #ffd700;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .sidebar-toggle {
                display: none;
            }

            .header h1 {
                font-size: 2.5rem;
            }

            .scoring-content {
                margin: 10px;
                padding: 25px;
            }

            .hand-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .hand-label-popup {
                width: auto;
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Animated background -->
    <div class="bg-particles" id="bgParticles"></div>

    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" id="sidebarToggle" title="Toggle sidebar">
        <span id="toggleIcon">◀</span>
        <span id="toggleText">Hide</span>
    </button>

    <div class="container">
        <div class="header">
            <h1>🔺 Pyramid Poker Online</h1>
            <div class="version-tag">Enhanced Edition - v2.0</div>
        </div>

        <div class="game-controls">
            <button id="newGame" class="btn btn-primary">New Game</button>
            <button id="addPlayer" class="btn btn-secondary">+Player</button>
            <button id="autoArrange" class="btn btn-secondary">Auto</button>
            <button id="sortByRank" class="btn btn-secondary">Rank</button>
            <button id="sortBySuit" class="btn btn-secondary">Suit</button>
            <button id="submitHand" class="btn btn-primary" disabled>Submit</button>
        </div>

        <div class="status" id="status">
            Click "New Game" to start playing!
        </div>

        <div class="game-area" id="gameArea">
            <div class="main-game">
                <div class="hand-section">
                    <div class="hand-label">
                        <span class="hand-icon">🎴</span>
                        Your Cards - Staging Area
                    </div>
                    <div class="hand-area staging-area" id="playerHand" data-hand="player"></div>
                </div>

                <div class="hand-section">
                    <div class="hand-label">
                        <span class="hand-icon">🏆</span>
                        Back Hand (5 cards) - Strongest
                        <span class="hand-strength" id="backStrength"></span>
                    </div>
                    <div class="hand-area" id="backHand" data-hand="back"></div>
                </div>

                <div class="hand-section">
                    <div class="hand-label">
                        <span class="hand-icon">🥈</span>
                        Middle Hand (5 cards) - Medium
                        <span class="hand-strength" id="middleStrength"></span>
                    </div>
                    <div class="hand-area" id="middleHand" data-hand="middle"></div>
                </div>

                <div class="hand-section">
                    <div class="hand-label">
                        <span class="hand-icon">🥉</span>
                        Front Hand (3 cards) - Weakest
                        <span class="hand-strength" id="frontStrength"></span>
                    </div>
                    <div class="hand-area" id="frontHand" data-hand="front"></div>
                </div>
            </div>

            <div class="sidebar" id="sidebar">
                <h3>Players</h3>
                <div class="player-list" id="playerList"></div>

                <div class="scoring" id="scoring" style="display: none;">
                    <h3>Current Scores</h3>
                    <div id="scoreList"></div>
                </div>

                <div class="rules">
                    <h3>Quick Rules</h3>
                    <p><strong>Goal:</strong> Arrange 13 cards into 3 hands where Back ≥ Middle ≥ Front in strength.</p>
                    <p><strong>Hands:</strong> Back (5), Middle (5), Front (3)</p>
                    <p><strong>Wild Card:</strong> 🃏 WILD can be any card you need!</p>
                    <p><strong>Scoring:</strong> Compare each hand with opponents. Win points for stronger hands.</p>
                    <p><strong>Bonus Points:</strong> Front trips (+2). Middle full house (+1), 4K (+7), SF (+9). Back 4K (+3), SF (+4).</p>
                    <p><strong>Fouling:</strong> If hands are out of order, you lose automatically!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Scoring Popup -->
    <div class="scoring-popup" id="scoringPopup">
        <div class="scoring-content">
            <button class="close-popup" onclick="game.closeScoringPopup()">×</button>
            <h2 style="text-align: center; margin-bottom: 30px; color: #ffd700;">🏆 Round Results</h2>

            <div class="player-hands-section">
                <h3 style="color: #ffd700; margin-bottom: 20px;">All Players' Hands</h3>
                <div id="allPlayerHands"></div>
            </div>

            <div class="round-robin-section">
                <h3 style="color: #ffd700; margin-bottom: 20px;">Round-Robin Scoring</h3>
                <div id="roundRobinResults"></div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-primary" onclick="game.closeScoringPopup()">Continue</button>
            </div>
        </div>
    </div>

    <script>
        // Create animated background particles
        function createParticles() {
            const container = document.getElementById('bgParticles');
            const particleCount = 20;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                container.appendChild(particle);
            }
        }

        class ChinesePokerGame {
            constructor() {
                this.players = [];
                this.currentPlayerIndex = 0;
                this.gameState = 'waiting';
                this.deck = [];
                this.playerHands = new Map();
                this.scores = new Map();
                this.submittedHands = new Map();
                this.sidebarVisible = true;

                this.initializeEventListeners();
                this.updateDisplay();
                createParticles();
            }

            initializeEventListeners() {
                document.getElementById('newGame').addEventListener('click', () => this.startNewGame());
                document.getElementById('addPlayer').addEventListener('click', () => this.addPlayer());
                document.getElementById('autoArrange').addEventListener('click', () => this.autoArrangeHand());
                document.getElementById('sortByRank').addEventListener('click', () => this.resetAndSortByRank());
                document.getElementById('sortBySuit').addEventListener('click', () => this.resetAndSortBySuit());
                document.getElementById('submitHand').addEventListener('click', () => this.submitCurrentHand());

                const toggleButton = document.getElementById('sidebarToggle');
                if (toggleButton) {
                    toggleButton.addEventListener('click', () => this.toggleSidebar());
                }

                this.setupDragAndDrop();
            }

            setupDragAndDrop() {
                const handAreas = document.querySelectorAll('.hand-area');

                document.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('card')) {
                        e.target.classList.add('dragging');
                        e.dataTransfer.setData('text/plain', e.target.dataset.card);
                        e.dataTransfer.setData('source', e.target.parentElement.id);
                    }
                });

                document.addEventListener('dragend', (e) => {
                    if (e.target.classList.contains('card')) {
                        e.target.classList.remove('dragging');
                    }
                });

                handAreas.forEach(area => {
                    area.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        area.classList.add('drop-target');
                    });

                    area.addEventListener('dragleave', (e) => {
                        if (!area.contains(e.relatedTarget)) {
                            area.classList.remove('drop-target');
                        }
                    });

                    area.addEventListener('drop', (e) => {
                        e.preventDefault();
                        area.classList.remove('drop-target');

                        const cardData = e.dataTransfer.getData('text/plain');
                        const sourceId = e.dataTransfer.getData('source');
                        const targetHand = area.dataset.hand;

                        this.moveCard(cardData, sourceId, targetHand);
                    });
                });
            }

            createDeck() {
                const suits = ['♠', '♥', '♦', '♣'];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                const deck = [];

                // Create two complete decks
                for (let deckNum = 1; deckNum <= 2; deckNum++) {
                    for (let suit of suits) {
                        for (let rank of ranks) {
                            deck.push({
                                suit,
                                rank,
                                value: this.getCardValue(rank),
                                id: `${rank}${suit}_${deckNum}`,
                                isWild: false
                            });
                        }
                    }
                }

                // Add two wild cards (Jokers)
                deck.push({
                    suit: '🃏',
                    rank: 'WILD',
                    value: 15,
                    id: 'WILD_JOKER_1',
                    isWild: true
                });

                deck.push({
                    suit: '🃏',
                    rank: 'WILD',
                    value: 15,
                    id: 'WILD_JOKER_2',
                    isWild: true
                });

                return this.shuffleDeck(deck);
            }

            getCardValue(rank) {
                if (rank === 'A') return 14;
                if (rank === 'K') return 13;
                if (rank === 'Q') return 12;
                if (rank === 'J') return 11;
                return parseInt(rank);
            }

            shuffleDeck(deck) {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }

            addPlayer() {
                const playerName = prompt('Enter player name:') || `Player ${this.players.length + 1}`;
                this.players.push({
                    name: playerName,
                    id: Date.now() + Math.random(),
                    ready: false
                });
                this.scores.set(playerName, 0);
                this.updateDisplay();
            }

            startNewGame() {
                if (this.players.length < 2) {
                    alert('Need at least 2 players to start!');
                    return;
                }

                // Hide sidebar when game starts to give more space for card play
                if (this.sidebarVisible) {
                    this.toggleSidebar();
                }

                this.deck = this.createDeck();
                this.gameState = 'playing';
                this.currentPlayerIndex = 0;
                this.submittedHands.clear();

                for (let player of this.players) {
                    const hand = this.deck.splice(0, 17);
                    this.playerHands.set(player.name, {
                        cards: hand,
                        back: [],
                        middle: [],
                        front: []
                    });
                    player.ready = false;
                }

                this.loadCurrentPlayerHand();
                this.updateDisplay();
            }

            loadCurrentPlayerHand() {
                if (this.gameState !== 'playing') return;

                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                document.getElementById('playerHand').innerHTML = '';
                document.getElementById('backHand').innerHTML = '';
                document.getElementById('middleHand').innerHTML = '';
                document.getElementById('frontHand').innerHTML = '';

                this.displayCards(playerData.cards, 'playerHand');
                this.displayCards(playerData.back, 'backHand');
                this.displayCards(playerData.middle, 'middleHand');
                this.displayCards(playerData.front, 'frontHand');

                this.validateHands();
            }

            displayCards(cards, containerId) {
                const container = document.getElementById(containerId);
                if (!container || !cards || cards.length === 0) return;

                cards.forEach(card => {
                    const cardElement = this.createCardElement(card);
                    container.appendChild(cardElement);
                });
            }

            createCardElement(card) {
                const cardEl = document.createElement('div');

                if (card.isWild) {
                    cardEl.className = 'card wild';
                    cardEl.innerHTML = `<div style="font-size: 16px;">WILD</div><div style="font-size: 28px;">🃏</div>`;
                } else {
                    cardEl.className = `card ${['♥', '♦'].includes(card.suit) ? 'red' : 'black'}`;
                    cardEl.innerHTML = `<div style="font-size: 20px;">${card.rank}</div><div style="font-size: 28px;">${card.suit}</div>`;
                }

                cardEl.draggable = true;
                cardEl.dataset.card = JSON.stringify(card);
                return cardEl;
            }

            moveCard(cardData, sourceId, targetHand) {
                const card = JSON.parse(cardData);
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                const sourceKey = this.getHandKey(sourceId);
                const sourceArray = sourceKey === 'cards' ? playerData.cards : playerData[sourceKey];
                const cardIndex = sourceArray.findIndex(c => c.id === card.id);

                if (cardIndex === -1) return;

                const targetKey = this.getHandKey(targetHand);
                const targetArray = targetKey === 'cards' ? playerData.cards : playerData[targetKey];

                if (targetKey === 'front' && targetArray.length >= 5) {
                    alert('Front hand can only have up to 5 cards!');
                    return;
                }

                if (targetKey === 'middle' && targetArray.length >= 7) {
                    alert('Middle hand can only have up to 7 cards!');
                    return;
                }

                if (targetKey === 'back' && targetArray.length >= 8) {
                    alert('Back hand can only have up to 8 cards!');
                    return;
                }

                // Allow going from 3 to 4 cards, but warn user they need 5
                if (targetKey === 'front' && targetArray.length === 3) {
                    // Just show a warning, but allow the move
                    setTimeout(() => {
                        alert('Front hand now has 4 cards. You must add 1 more card to make it a valid 5-card hand!');
                    }, 100);
                }

                sourceArray.splice(cardIndex, 1);
                targetArray.push(card);

                this.loadCurrentPlayerHand();
            }

            getHandKey(elementId) {
                switch (elementId) {
                    case 'playerHand': return 'cards';
                    case 'backHand': case 'back': return 'back';
                    case 'middleHand': case 'middle': return 'middle';
                    case 'frontHand': case 'front': return 'front';
                    default: return 'cards';
                }
            }

            validateHands() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                const backHand = document.getElementById('backHand');
                const middleHand = document.getElementById('middleHand');
                const frontHand = document.getElementById('frontHand');
                const submitBtn = document.getElementById('submitHand');
                const statusDiv = document.getElementById('status');

                // Reset classes
                [backHand, middleHand, frontHand].forEach(hand => {
                    hand.classList.remove('valid', 'invalid');
                });

                // Check card counts and total
                const backCount = playerData.back.length;
                const middleCount = playerData.middle.length;
                const frontCount = playerData.front.length;
                const totalPlaced = backCount + middleCount + frontCount;
                const totalCards = playerData.cards.length + totalPlaced; // Re-added this line

                // Validate hand sizes - new flexible limits
                const isValidCounts = backCount <= 8 && middleCount <= 7 && (frontCount <= 5);
                const isValidFrontSize = frontCount === 3 || frontCount === 5; // No 4 cards allowed
                const isValidBackSize = [5, 6, 7, 8].includes(backCount) || backCount === 0; // 0 for incomplete
                const isValidMiddleSize = [5, 6, 7].includes(middleCount) || middleCount === 0; // 0 for incomplete

                // Calculate expected total based on hand sizes
                let expectedTotal = 0;
                if (frontCount === 3 || frontCount === 5) expectedTotal += frontCount;
                if (isValidBackSize && backCount > 0) expectedTotal += backCount;
                if (isValidMiddleSize && middleCount > 0) expectedTotal += middleCount;

                const isComplete = (backCount > 0 && middleCount > 0 && frontCount > 0) &&
                                  isValidFrontSize && isValidBackSize && isValidMiddleSize;

                if (!isValidCounts || !isValidFrontSize || !isValidBackSize || !isValidMiddleSize) {
                    // Mark oversized hands as invalid
                    if (backCount > 8) backHand.classList.add('invalid');
                    if (middleCount > 7) middleHand.classList.add('invalid');
                    if (frontCount > 5 || frontCount === 4) frontHand.classList.add('invalid');

                    submitBtn.disabled = true;

                    let backError = '';
                    if (backCount > 8) backError = ' (TOO MANY!)';
                    else if (backCount > 0 && !isValidBackSize) backError = ' (INVALID SIZE!)';

                    let middleError = '';
                    if (middleCount > 7) middleError = ' (TOO MANY!)';
                    else if (middleCount > 0 && !isValidMiddleSize) middleError = ' (INVALID SIZE!)';

                    let frontError = '';
                    if (frontCount > 5) frontError = ' (TOO MANY!)';
                    else if (frontCount === 4) frontError = ' (4 CARDS NOT ALLOWED!)';

                    document.getElementById('backStrength').textContent = `${backCount}/5-8 cards${backError}`;
                    document.getElementById('middleStrength').textContent = `${middleCount}/5-7 cards${middleError}`;
                    document.getElementById('frontStrength').textContent = `${frontCount}/3 or 5 cards${frontError}`;
                    return;
                }

                if (isComplete) {
                    // Evaluate hand strengths
                    const backStrength = this.evaluateHand(playerData.back);
                    const middleStrength = this.evaluateHand(playerData.middle);
                    const frontStrength = this.evaluateThreeCardHand(playerData.front);

                    // Special validation: 5-card front hands must be at least a straight
                    let frontIsValid = true;
                    if (frontCount === 5) {
                        // Check if 5-card front hand is at least a straight (rank 4 or higher)
                        if (frontStrength.hand_rank[0] < 5) { // Straight is rank 5, so anything less is invalid
                            frontIsValid = false;
                        }
                    }

                    // Check if hands are in proper order (Back >= Middle >= Front)
                    const backTuple = backStrength.hand_rank;
                    const middleTuple = middleStrength.hand_rank;
                    const frontTuple = frontStrength.hand_rank;

                    console.log('Validation Debug:');
                    console.log('Back hand:', backStrength.name, backTuple);
                    console.log('Middle hand:', middleStrength.name, middleTuple);
                    console.log('Front hand:', frontStrength.name, frontTuple);
                    console.log('Front hand valid (if 5-card)?', frontIsValid);

                    const backVsMiddle = this.compareTuples(backTuple, middleTuple);
                    const middleVsFront = this.compareTuples(middleTuple, frontTuple);

                    console.log('Back >= Middle?', backVsMiddle >= 0);
                    console.log('Middle >= Front?', middleVsFront >= 0);

                    const isValidOrder = backVsMiddle >= 0 && middleVsFront >= 0 && frontIsValid;

                    // Display hand strengths with bonus indicators
                    document.getElementById('backStrength').textContent = `${this.getHandName(backStrength)} (${backStrength.hand_rank.join(', ')})${this.getBackBonus(backStrength)}`;
                    document.getElementById('middleStrength').textContent = `${this.getHandName(middleStrength)} (${middleStrength.hand_rank.join(', ')})${this.getMiddleBonus(middleStrength)}`;
                    document.getElementById('frontStrength').textContent = `${this.getThreeCardHandName(frontStrength)} (${frontStrength.hand_rank.join(', ')})${this.getFrontBonus(frontStrength)}`;

                    if (isValidOrder) {
                        // Setup is completely valid
                        backHand.classList.add('valid');
                        middleHand.classList.add('valid');
                        frontHand.classList.add('valid');
                        submitBtn.disabled = false;

                        // Update status to show setup is valid
                        const currentPlayer = this.players[this.currentPlayerIndex];
                        const readyCount = this.players.filter(p => p.ready).length;
                        statusDiv.innerHTML = `${currentPlayer.name}'s turn - <span style="color: #4ecdc4; font-weight: bold;">✓ SETUP VALID</span> - Ready to submit! (${readyCount}/${this.players.length} players ready)`;
                    } else {
                        // Hands are out of order or front hand invalid
                        backHand.classList.add('invalid');
                        middleHand.classList.add('invalid');
                        frontHand.classList.add('invalid');
                        submitBtn.disabled = true;

                        // Update status to show setup is invalid with specific reason
                        const currentPlayer = this.players[this.currentPlayerIndex];
                        const readyCount = this.players.filter(p => p.ready).length;
                        let reason = '';
                        if (!frontIsValid) reason = '5-card front hand must be at least a Straight';
                        else if (backVsMiddle < 0) reason = 'Back hand must be >= Middle hand';
                        else if (middleVsFront < 0) reason = 'Middle hand must be >= Front hand';

                        statusDiv.innerHTML = `${currentPlayer.name}'s turn - <span style="color: #ff6b6b; font-weight: bold;">✗ INVALID ORDER</span> - ${reason}! (${readyCount}/${this.players.length} players ready)`;
                    }
                } else {
                    submitBtn.disabled = true;
                    document.getElementById('backStrength').textContent = `${backCount}/5 cards`;
                    document.getElementById('middleStrength').textContent = `${middleCount}/5 cards`;
                    document.getElementById('frontStrength').textContent = `${frontCount}/3 cards`;

                    // Update status to show incomplete setup
                    const currentPlayer = this.players[this.currentPlayerIndex];
                    const readyCount = this.players.filter(p => p.ready).length;
                    const cardsInPlay = totalPlaced;
                    const cardsRemaining = totalCards - totalPlaced;

                    let expectedCards = frontCount === 3 ? 13 : 15; // 13 for 3-card front, 15 for 5-card front
                    let frontExpected = frontCount === 3 ? '3' : frontCount === 5 ? '5' : '3 or 5';

                    statusDiv.innerHTML = `${currentPlayer.name}'s turn - <span style="color: #ffd700; font-weight: bold;">⚠ INCOMPLETE</span> - Need ${expectedCards} cards in play (${totalPlaced}/${expectedCards} placed, ${cardsRemaining} in staging) - Front: ${frontCount}/${frontExpected} (${readyCount}/${this.players.length} players ready)`;
                }
            }

            evaluateHand(cards) {
                // Handle large hands (6, 7, 8 cards) - temporary basic evaluation
                if (cards.length > 5) {
                    return { rank: 0, hand_rank: [0, cards.length], name: `${cards.length}-Card Hand` };
                }

                if (cards.length !== 5) return { rank: 0, hand_rank: [0, 0], name: 'Invalid' };

                const wildCards = cards.filter(c => c.isWild);
                const normalCards = cards.filter(c => !c.isWild);

                if (wildCards.length > 0) {
                    return this.evaluateHandWithWilds(normalCards, wildCards.length);
                }

                const sortedCards = [...cards].sort((a, b) => b.value - a.value);
                const suits = cards.map(c => c.suit);
                const values = sortedCards.map(c => c.value);

                const isFlush = suits.every(suit => suit === suits[0]);
                const isStraight = this.isStraight(values);

                // Count values - this now properly handles duplicates from two decks
                const valueCounts = {};
                values.forEach(val => valueCounts[val] = (valueCounts[val] || 0) + 1);

                // Group values by count frequency
                const valuesByCount = {};
                for (const [value, count] of Object.entries(valueCounts)) {
                    if (!valuesByCount[count]) valuesByCount[count] = [];
                    valuesByCount[count].push(parseInt(value));
                }

                // Sort each group by descending value
                for (const count in valuesByCount) {
                    valuesByCount[count].sort((a, b) => b - a);
                }

                const counts = Object.keys(valuesByCount).map(Number).sort((a, b) => b - a);

                // Check for five of a kind (only possible with two decks + wilds)
                if (counts[0] === 5) {
                    const fiveRank = valuesByCount[5][0];
                    return { rank: 9, hand_rank: [10, fiveRank], name: 'Five of a Kind' };
                }

                if (isStraight && isFlush) {
                    return { rank: 8, hand_rank: [9, values[0]], name: 'Straight Flush' };
                }

                if (counts[0] === 4) {
                    // Four of a Kind: [8, quad_rank, kicker]
                    const quadRank = valuesByCount[4][0];
                    const kicker = valuesByCount[1][0];
                    return { rank: 7, hand_rank: [8, quadRank, kicker], name: 'Four of a Kind' };
                }

                if (counts[0] === 3 && counts[1] === 2) {
                    // Full House: [7, trips_rank, pair_rank]
                    const tripsRank = valuesByCount[3][0];
                    const pairRank = valuesByCount[2][0];
                    return { rank: 6, hand_rank: [7, tripsRank, pairRank], name: 'Full House' };
                }

                if (isFlush) {
                    // Flush: [6, high, second, third, fourth, fifth]
                    return { rank: 5, hand_rank: [6, ...values], name: 'Flush' };
                }

                if (isStraight) {
                    return { rank: 4, hand_rank: [5, values[0]], name: 'Straight' };
                }

                if (counts[0] === 3) {
                    // Three of a Kind: [4, trips_rank, kicker1, kicker2]
                    const tripsRank = valuesByCount[3][0];
                    const kickers = valuesByCount[1] ? valuesByCount[1].slice(0, 2) : [];
                    return { rank: 3, hand_rank: [4, tripsRank, ...kickers], name: 'Three of a Kind' };
                }

                if (counts[0] === 2) {
                    // Check if we have two pairs
                    if (valuesByCount[2] && valuesByCount[2].length >= 2) {
                        // Two Pair: [3, higher_pair, lower_pair, kicker]
                        const pairs = valuesByCount[2];
                        const higherPair = Math.max(...pairs);
                        const lowerPair = Math.min(...pairs);
                        const kicker = valuesByCount[1] ? valuesByCount[1][0] : 0;
                        return { rank: 2, hand_rank: [3, higherPair, lowerPair, kicker], name: 'Two Pair' };
                    } else {
                        // Single Pair: [2, pair_rank, kicker1, kicker2, kicker3]
                        const pairRank = valuesByCount[2][0];
                        const kickers = valuesByCount[1] ? valuesByCount[1].slice(0, 3) : [];
                        return { rank: 1, hand_rank: [2, pairRank, ...kickers], name: 'Pair' };
                    }
                }

                // High Card: [1, high, second, third, fourth, fifth]
                return { rank: 0, hand_rank: [1, ...values], name: 'High Card' };
            }

            isStraight(values) {
                for (let i = 0; i < values.length - 1; i++) {
                    if (values[i] - values[i + 1] !== 1) {
                        if (values[0] === 14 && values[1] === 5 && values[2] === 4 && values[3] === 3 && values[4] === 2) {
                            return true;
                        }
                        return false;
                    }
                }
                return true;
            }

            evaluateHandWithWilds(normalCards, wildCount) {
                // With wilds, find the BEST possible hand by trying all possibilities
                const values = normalCards.map(c => c.value).sort((a, b) => b - a);
                const suits = normalCards.map(c => c.suit);

                // Count existing values to see what we can build on
                const valueCounts = {};
                values.forEach(val => valueCounts[val] = (valueCounts[val] || 0) + 1);

                // Count suits
                const suitCounts = {};
                suits.forEach(suit => suitCounts[suit] = (suitCounts[suit] || 0) + 1);

                // CORRECT ORDER: Find the BEST possible hand

                // 1. Try for Five of a Kind
                for (const [value, count] of Object.entries(valueCounts)) {
                    if (count + wildCount >= 5) {
                        const fiveRank = parseInt(value);
                        return { rank: 9, hand_rank: [10, fiveRank], name: 'Five of a Kind (Wild)' };
                    }
                }
                if (wildCount >= 4) {
                    const highCard = values[0] || 14;
                    return { rank: 9, hand_rank: [10, highCard], name: 'Five of a Kind (Wild)' };
                }

                // 2. Try for Straight Flush
                const straightFlush = this.tryForStraightFlushWithWilds(normalCards, wildCount);
                if (straightFlush) return straightFlush;

                // 3. Try for Four of a Kind
                for (const [value, count] of Object.entries(valueCounts)) {
                    if (count + wildCount >= 4) {
                        const quadRank = parseInt(value);
                        const remainingCards = normalCards.filter(c => c.value !== quadRank);
                        const kicker = remainingCards.length > 0 ? Math.max(...remainingCards.map(c => c.value)) : 13;
                        return { rank: 7, hand_rank: [8, quadRank, kicker], name: 'Four of a Kind (Wild)' };
                    }
                }
                if (wildCount >= 3) {
                    const quadRank = values[0] || 14;
                    const kicker = values[1] || 13;
                    return { rank: 7, hand_rank: [8, quadRank, kicker], name: 'Four of a Kind (Wild)' };
                }

                // 4. Try for Full House
                const pairs = Object.entries(valueCounts).filter(([v, c]) => c >= 2);
                const singles = Object.entries(valueCounts).filter(([v, c]) => c === 1);

                if (pairs.length >= 2 && wildCount >= 1) {
                    const sortedPairs = pairs.sort((a, b) => parseInt(b[0]) - parseInt(a[0]));
                    const tripsRank = parseInt(sortedPairs[0][0]);
                    const pairRank = parseInt(sortedPairs[1][0]);
                    return { rank: 6, hand_rank: [7, tripsRank, pairRank], name: 'Full House (Wild)' };
                }
                if (pairs.length >= 1 && singles.length >= 1 && wildCount >= 2) {
                    const pairRank = parseInt(pairs[0][0]);
                    const singleRank = parseInt(singles[0][0]);
                    const tripsRank = Math.max(pairRank, singleRank);
                    const finalPairRank = Math.min(pairRank, singleRank);
                    return { rank: 6, hand_rank: [7, tripsRank, finalPairRank], name: 'Full House (Wild)' };
                }
                if (singles.length >= 2 && wildCount >= 3) {
                    const sortedSingles = singles.sort((a, b) => parseInt(b[0]) - parseInt(a[0]));
                    const tripsRank = parseInt(sortedSingles[0][0]);
                    const pairRank = parseInt(sortedSingles[1][0]);
                    return { rank: 6, hand_rank: [7, tripsRank, pairRank], name: 'Full House (Wild)' };
                }

                // 5. Try for Flush
                const flush = this.tryForFlushWithWilds(normalCards, wildCount);
                if (flush) return flush;

                // 6. Try for Straight
                const straight = this.tryForStraightWithWilds(normalCards, wildCount);
                if (straight) return straight;

                // 7. Try for Three of a Kind
                for (const [value, count] of Object.entries(valueCounts)) {
                    if (count + wildCount >= 3) {
                        const tripsRank = parseInt(value);
                        const remainingCards = normalCards.filter(c => c.value !== tripsRank);
                        const kickers = remainingCards.map(c => c.value).sort((a, b) => b - a).slice(0, 2);
                        while (kickers.length < 2) kickers.push(13 - kickers.length);
                        return { rank: 3, hand_rank: [4, tripsRank, ...kickers], name: 'Three of a Kind (Wild)' };
                    }
                }
                if (wildCount >= 2) {
                    const tripsRank = values[0] || 14;
                    const remainingValues = values.filter(v => v !== tripsRank);
                    const kickers = remainingValues.slice(0, 2);
                    while (kickers.length < 2) kickers.push(13 - kickers.length);
                    return { rank: 3, hand_rank: [4, tripsRank, ...kickers], name: 'Three of a Kind (Wild)' };
                }

                // 8. Try for Two Pair
                if (pairs.length >= 1 && singles.length >= 1 && wildCount >= 1) {
                    const pairRank = parseInt(pairs[0][0]);
                    const secondPairRank = parseInt(singles[0][0]);
                    const higherPair = Math.max(pairRank, secondPairRank);
                    const lowerPair = Math.min(pairRank, secondPairRank);
                    const kicker = singles.length > 1 ? parseInt(singles[1][0]) : 13;
                    return { rank: 2, hand_rank: [3, higherPair, lowerPair, kicker], name: 'Two Pair (Wild)' };
                }

                // 9. Try for Pair
                if (wildCount >= 1) {
                    const pairRank = values[0] || 14;
                    const remainingValues = values.filter(v => v !== pairRank);
                    const kickers = remainingValues.slice(0, 3);
                    while (kickers.length < 3) kickers.push(13 - kickers.length);
                    return { rank: 1, hand_rank: [2, pairRank, ...kickers], name: 'Pair (Wild)' };
                }

                // 10. High Card (fallback)
                const allValues = [...values];
                while (allValues.length < 5) allValues.push(14 - allValues.length);
                return { rank: 0, hand_rank: [1, ...allValues.slice(0, 5)], name: 'High Card (Wild)' };
            }

            tryForStraightFlushWithWilds(normalCards, wildCount) {
                // Group cards by suit
                const suitGroups = {};
                normalCards.forEach(card => {
                    suitGroups[card.suit] = (suitGroups[card.suit] || []).concat(card);
                });

                // Check each suit to see if we can make a straight flush
                for (const [suit, cards] of Object.entries(suitGroups)) {
                    if (cards.length + wildCount >= 5) {
                        const values = cards.map(c => c.value).sort((a, b) => b - a);
                        const uniqueValues = [...new Set(values)];

                        // Try all possible straight flushes from HIGHEST to LOWEST
                        const possibleStraights = [
                            [14, 13, 12, 11, 10], // Royal Flush (A-K-Q-J-10)
                            [13, 12, 11, 10, 9],  // K-Q-J-10-9
                            [12, 11, 10, 9, 8],   // Q-J-10-9-8
                            [11, 10, 9, 8, 7],    // J-10-9-8-7
                            [10, 9, 8, 7, 6],     // 10-9-8-7-6
                            [9, 8, 7, 6, 5],      // 9-8-7-6-5
                            [8, 7, 6, 5, 4],      // 8-7-6-5-4
                            [7, 6, 5, 4, 3],      // 7-6-5-4-3
                            [6, 5, 4, 3, 2],      // 6-5-4-3-2
                            [14, 5, 4, 3, 2]      // Steel Wheel (A-5-4-3-2)
                        ];

                        // Check each straight from highest to lowest
                        for (const straight of possibleStraights) {
                            const needed = straight.filter(v => !uniqueValues.includes(v)).length;
                            if (needed <= wildCount) {
                                const highCard = straight[0] === 14 && straight[1] === 5 ? 5 : straight[0]; // Handle wheel
                                const name = straight[0] === 14 && straight[1] === 13 ? 'Royal Flush (Wild)' : 'Straight Flush (Wild)';
                                return { rank: 8, hand_rank: [9, highCard], name: name };
                            }
                        }
                    }
                }
                return null;
            }

            tryForFlushWithWilds(normalCards, wildCount) {
                const suitCounts = {};
                normalCards.forEach(c => suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1);

                for (const [suit, count] of Object.entries(suitCounts)) {
                    if (count + wildCount >= 5) {
                        const flushCards = normalCards.filter(c => c.suit === suit);
                        const values = flushCards.map(c => c.value).sort((a, b) => b - a);

                        // Add optimal high cards for the wild cards to make the best flush
                        while (values.length < 5) {
                            // Add the highest possible card that doesn't duplicate existing values
                            let nextHighCard = 14; // Start with Ace
                            while (values.includes(nextHighCard) && nextHighCard > 2) {
                                nextHighCard--;
                            }
                            values.push(nextHighCard);
                            values.sort((a, b) => b - a); // Keep sorted
                        }

                        return { rank: 5, hand_rank: [6, ...values.slice(0, 5)], name: 'Flush (Wild)' };
                    }
                }
                return null;
            }

            tryForStraightWithWilds(normalCards, wildCount) {
                const values = [...new Set(normalCards.map(c => c.value))].sort((a, b) => b - a);

                // Try all possible straights from HIGHEST to LOWEST to find the best one
                const possibleStraights = [
                    [14, 13, 12, 11, 10], // A-K-Q-J-10 (Broadway - highest)
                    [13, 12, 11, 10, 9],  // K-Q-J-10-9
                    [12, 11, 10, 9, 8],   // Q-J-10-9-8
                    [11, 10, 9, 8, 7],    // J-10-9-8-7
                    [10, 9, 8, 7, 6],     // 10-9-8-7-6
                    [9, 8, 7, 6, 5],      // 9-8-7-6-5
                    [8, 7, 6, 5, 4],      // 8-7-6-5-4
                    [7, 6, 5, 4, 3],      // 7-6-5-4-3
                    [6, 5, 4, 3, 2],      // 6-5-4-3-2
                    [14, 5, 4, 3, 2]      // A-5-4-3-2 (wheel - lowest)
                ];

                // Check each straight from highest to lowest - return the FIRST (highest) one that works
                for (const straight of possibleStraights) {
                    const needed = straight.filter(v => !values.includes(v)).length;
                    if (needed <= wildCount) {
                        const highCard = straight[0] === 14 && straight[1] === 5 ? 5 : straight[0]; // Handle wheel straight
                        return { rank: 4, hand_rank: [5, highCard], name: 'Straight (Wild)' };
                    }
                }
                return null;
            }

            evaluateThreeCardHand(cards) {
                // Handle both 3-card and 5-card front hands
                if (cards.length === 5) {
                    // Use the regular 5-card evaluation for 5-card front hands
                    return this.evaluateHand(cards);
                }

                if (cards.length !== 3) return { rank: 0, hand_rank: [0, 0], name: 'Invalid' };

                // Handle wild cards in 3-card hands
                const wildCards = cards.filter(c => c.isWild);
                const normalCards = cards.filter(c => !c.isWild);

                if (wildCards.length > 0) {
                    return this.evaluateThreeCardHandWithWilds(normalCards, wildCards.length);
                }

                const sortedCards = [...cards].sort((a, b) => b.value - a.value);
                const values = sortedCards.map(c => c.value);

                const valueCounts = {};
                values.forEach(val => valueCounts[val] = (valueCounts[val] || 0) + 1);

                const valuesByCount = {};
                for (const [value, count] of Object.entries(valueCounts)) {
                    if (!valuesByCount[count]) valuesByCount[count] = [];
                    valuesByCount[count].push(parseInt(value));
                }

                for (const count in valuesByCount) {
                    valuesByCount[count].sort((a, b) => b - a);
                }

                const counts = Object.keys(valuesByCount).map(Number).sort((a, b) => b - a);

                if (counts[0] === 3) {
                    const tripsRank = valuesByCount[3][0];
                    return { rank: 3, hand_rank: [4, tripsRank], name: 'Three of a Kind' };
                }

                if (counts[0] === 2) {
                    const pairRank = valuesByCount[2][0];
                    const kicker = valuesByCount[1][0];
                    return { rank: 1, hand_rank: [2, pairRank, kicker], name: 'Pair' };
                }

                return { rank: 0, hand_rank: [1, ...values], name: 'High Card' };
            }

            evaluateThreeCardHandWithWilds(normalCards, wildCount) {
                const values = normalCards.map(c => c.value).sort((a, b) => b - a);
                const highCard = values[0] || 14;

                if (wildCount >= 2) {
                    return { rank: 3, hand_rank: [4, highCard], name: 'Three of a Kind (Wild)' };
                }

                if (wildCount === 1) {
                    const pairRank = highCard;
                    const kicker = values.find(v => v !== pairRank) || 13;
                    return { rank: 1, hand_rank: [2, pairRank, kicker], name: 'Pair (Wild)' };
                }

                const allValues = [...values];
                while (allValues.length < 3) allValues.push(13 - allValues.length);
                return { rank: 0, hand_rank: [1, ...allValues.slice(0, 3)], name: 'High Card' };
            }

            getHandName(evaluation) {
                return evaluation.name;
            }

            getThreeCardHandName(evaluation) {
                return evaluation.name;
            }

            resetCards() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                const allCards = [...playerData.cards, ...playerData.back, ...playerData.middle, ...playerData.front];

                playerData.cards = allCards;
                playerData.back = [];
                playerData.middle = [];
                playerData.front = [];

                this.loadCurrentPlayerHand();
            }

            autoArrangeHand() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                const allCards = [...playerData.cards, ...playerData.back, ...playerData.middle, ...playerData.front];

                if (allCards.length !== 17) {
                    alert(`Card count error: Found ${allCards.length} cards instead of 17!`);
                    return;
                }

                // Sort all cards and pick the best 13 for play, leave 4 best rejects in staging
                const sortedCards = [...allCards].sort((a, b) => b.value - a.value);

                // Take the best 13 cards for play
                const playCards = sortedCards.slice(0, 13);
                const stagingCards = sortedCards.slice(13, 17); // 4 worst cards stay in staging

                const backHand = playCards.slice(0, 5);   // 5 best cards
                const middleHand = playCards.slice(5, 10); // next 5 cards
                const frontHand = playCards.slice(10, 13); // next 3 cards

                playerData.cards = stagingCards; // 4 cards left in staging
                playerData.back = backHand;
                playerData.middle = middleHand;
                playerData.front = frontHand;

                this.loadCurrentPlayerHand();
            }

            resetAndSortByRank() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                // First reset: collect all cards from all hands
                const allCards = [...playerData.cards, ...playerData.back, ...playerData.middle, ...playerData.front];

                // Then sort by rank (high to low)
                allCards.sort((a, b) => {
                    if (a.value !== b.value) {
                        return b.value - a.value; // High to low
                    }
                    // If same rank, sort by suit order (spades, hearts, diamonds, clubs)
                    const suitOrder = { '♠': 4, '♥': 3, '♦': 2, '♣': 1 };
                    return suitOrder[b.suit] - suitOrder[a.suit];
                });

                // Put all cards back in staging area
                playerData.cards = allCards;
                playerData.back = [];
                playerData.middle = [];
                playerData.front = [];

                this.loadCurrentPlayerHand();
            }

            resetAndSortBySuit() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                // First reset: collect all cards from all hands
                const allCards = [...playerData.cards, ...playerData.back, ...playerData.middle, ...playerData.front];

                // Then sort by suit, then by rank within each suit
                allCards.sort((a, b) => {
                    // First sort by suit (spades, hearts, diamonds, clubs)
                    const suitOrder = { '♠': 4, '♥': 3, '♦': 2, '♣': 1 };
                    if (a.suit !== b.suit) {
                        return suitOrder[b.suit] - suitOrder[a.suit];
                    }
                    // Within same suit, sort by rank (high to low)
                    return b.value - a.value;
                });

                // Put all cards back in staging area
                playerData.cards = allCards;
                playerData.back = [];
                playerData.middle = [];
                playerData.front = [];

                this.loadCurrentPlayerHand();
            }

            sortCardsByRank() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                playerData.cards.sort((a, b) => {
                    if (a.value !== b.value) {
                        return b.value - a.value;
                    }
                    const suitOrder = { '♠': 4, '♥': 3, '♦': 2, '♣': 1 };
                    return suitOrder[b.suit] - suitOrder[a.suit];
                });

                this.loadCurrentPlayerHand();
            }

            sortCardsBySuit() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                playerData.cards.sort((a, b) => {
                    const suitOrder = { '♠': 4, '♥': 3, '♦': 2, '♣': 1 };
                    if (a.suit !== b.suit) {
                        return suitOrder[b.suit] - suitOrder[a.suit];
                    }
                    return b.value - a.value;
                });

                this.loadCurrentPlayerHand();
            }

            submitCurrentHand() {
                const currentPlayer = this.players[this.currentPlayerIndex];
                const playerData = this.playerHands.get(currentPlayer.name);

                if (!playerData) return;

                const totalPlaced = playerData.back.length + playerData.middle.length + playerData.front.length;
                const frontCount = playerData.front.length;
                const expectedTotal = frontCount === 3 ? 13 : 15;

                if (totalPlaced !== expectedTotal || playerData.back.length !== 5 ||
                    playerData.middle.length !== 5 || (frontCount !== 3 && frontCount !== 5)) {
                    alert(`Please arrange exactly ${expectedTotal} cards: 5 in back, 5 in middle, ${frontCount === 3 ? '3' : '5'} in front! You can leave ${17 - expectedTotal} cards in staging area.`);
                    return;
                }

                const backStrength = this.evaluateHand(playerData.back);
                const middleStrength = this.evaluateHand(playerData.middle);
                const frontStrength = this.evaluateThreeCardHand(playerData.front);

                const backTuple = backStrength.hand_rank;
                const middleTuple = middleStrength.hand_rank;
                const frontTuple = frontStrength.hand_rank;

                const isValidOrder = this.compareTuples(backTuple, middleTuple) >= 0 &&
                                   this.compareTuples(middleTuple, frontTuple) >= 0;

                if (!isValidOrder) {
                    const message = `INVALID HAND ORDER!\n\n` +
                        `Back Hand: ${backStrength.name} (${backStrength.hand_rank.join(', ')})\n` +
                        `Middle Hand: ${middleStrength.name} (${middleStrength.hand_rank.join(', ')})\n` +
                        `Front Hand: ${frontStrength.name} (${frontStrength.hand_rank.join(', ')})\n\n` +
                        `Rule: Back ≥ Middle ≥ Front`;

                    if (confirm(message + '\n\nWould you like to reset your cards and try again?')) {
                        this.resetCards();
                    }
                    return;
                }

                this.submittedHands.set(currentPlayer.name, {
                    back: [...playerData.back],
                    middle: [...playerData.middle],
                    front: [...playerData.front]
                });

                currentPlayer.ready = true;

                this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;

                const allReady = this.players.every(p => p.ready);

                if (allReady) {
                    this.calculateScores();
                    this.gameState = 'scoring';
                } else {
                    this.loadCurrentPlayerHand();
                }

                this.updateDisplay();
            }

            calculateScores() {
                const playerNames = this.players.map(p => p.name);
                const roundScores = new Map();
                const detailedResults = [];
                const bonusPoints = new Map();

                playerNames.forEach(name => {
                    roundScores.set(name, 0);
                    bonusPoints.set(name, 0);
                });

                playerNames.forEach(playerName => {
                    const hand = this.submittedHands.get(playerName);
                    let playerBonus = 0;

                    const frontEval = this.evaluateThreeCardHand(hand.front);

                    // Front hand bonuses - different for 3-card vs 5-card
                    if (hand.front.length === 3) {
                        // 3-card front hand bonuses
                        if (frontEval.hand_rank[0] === 4) { // Three of a kind
                            playerBonus += 2;
                        }
                    } else if (hand.front.length === 5) {
                        // 5-card front hand bonuses
                        if (frontEval.hand_rank[0] === 10) { // Five of a Kind
                            playerBonus += 17;
                        } else if (frontEval.hand_rank[0] === 9) { // Straight Flush
                            playerBonus += 14;
                        } else if (frontEval.hand_rank[0] === 8) { // Four of a Kind
                            playerBonus += 11;
                        } else if (frontEval.hand_rank[0] === 7) { // Full House
                            playerBonus += 4;
                        } else if (frontEval.hand_rank[0] === 6) { // Flush
                            playerBonus += 3;
                        } else if (frontEval.hand_rank[0] === 5) { // Straight
                            playerBonus += 3;
                        }
                    }

                    const middleEval = this.evaluateHand(hand.middle);
                    if (middleEval.hand_rank[0] === 10) { // Five of a Kind
                        playerBonus += 5;
                    } else if (middleEval.hand_rank[0] === 7) { // Full House
                        playerBonus += 1;
                    } else if (middleEval.hand_rank[0] === 8) { // Four of a Kind
                        playerBonus += 7;
                    } else if (middleEval.hand_rank[0] === 9) { // Straight Flush
                        playerBonus += 9;
                    }

                    const backEval = this.evaluateHand(hand.back);
                    if (backEval.hand_rank[0] === 10) { // Five of a Kind
                        playerBonus += 5;
                    } else if (backEval.hand_rank[0] === 8) { // Four of a Kind
                        playerBonus += 3;
                    } else if (backEval.hand_rank[0] === 9) { // Straight Flush
                        playerBonus += 4;
                    }

                    bonusPoints.set(playerName, playerBonus);
                    roundScores.set(playerName, playerBonus);
                });

                for (let i = 0; i < playerNames.length; i++) {
                    for (let j = i + 1; j < playerNames.length; j++) {
                        const player1 = playerNames[i];
                        const player2 = playerNames[j];

                        const hand1 = this.submittedHands.get(player1);
                        const hand2 = this.submittedHands.get(player2);

                        const result = this.compareHands(hand1, hand2);

                        roundScores.set(player1, roundScores.get(player1) + result.player1Score);
                        roundScores.set(player2, roundScores.get(player2) + result.player2Score);

                        detailedResults.push({
                            player1,
                            player2,
                            player1Score: result.player1Score,
                            player2Score: result.player2Score,
                            details: result.details,
                            sweepBonus: result.sweepBonus
                        });
                    }
                }

                roundScores.forEach((roundScore, playerName) => {
                    this.scores.set(playerName, this.scores.get(playerName) + roundScore);
                });

                this.showScoringPopup(detailedResults, roundScores, bonusPoints);
                this.updateDisplay();
            }

            compareTuples(tuple1, tuple2) {
                const minLength = Math.min(tuple1.length, tuple2.length);

                for (let i = 0; i < minLength; i++) {
                    if (tuple1[i] > tuple2[i]) return 1;
                    if (tuple1[i] < tuple2[i]) return -1;
                }

                if (tuple1.length > tuple2.length) return 1;
                if (tuple1.length < tuple2.length) return -1;
                return 0;
            }

            compareHands(hand1, hand2) {
                let player1Score = 0;
                let player2Score = 0;
                const details = [];

                const back1 = this.evaluateHand(hand1.back);
                const back2 = this.evaluateHand(hand2.back);
                const backComparison = this.compareTuples(back1.hand_rank, back2.hand_rank);
                let backResult = 'tie';
                if (backComparison > 0) {
                    player1Score += 1;
                    backResult = 'player1';
                } else if (backComparison < 0) {
                    player2Score += 1;
                    backResult = 'player2';
                }
                details.push({
                    hand: 'Back',
                    player1Hand: back1,
                    player2Hand: back2,
                    winner: backResult
                });

                const middle1 = this.evaluateHand(hand1.middle);
                const middle2 = this.evaluateHand(hand2.middle);
                const middleComparison = this.compareTuples(middle1.hand_rank, middle2.hand_rank);
                let middleResult = 'tie';
                if (middleComparison > 0) {
                    player1Score += 1;
                    middleResult = 'player1';
                } else if (middleComparison < 0) {
                    player2Score += 1;
                    middleResult = 'player2';
                }
                details.push({
                    hand: 'Middle',
                    player1Hand: middle1,
                    player2Hand: middle2,
                    winner: middleResult
                });

                const front1 = this.evaluateThreeCardHand(hand1.front);
                const front2 = this.evaluateThreeCardHand(hand2.front);
                const frontComparison = this.compareTuples(front1.hand_rank, front2.hand_rank);
                let frontResult = 'tie';
                if (frontComparison > 0) {
                    player1Score += 1;
                    frontResult = 'player1';
                } else if (frontComparison < 0) {
                    player2Score += 1;
                    frontResult = 'player2';
                }
                details.push({
                    hand: 'Front',
                    player1Hand: front1,
                    player2Hand: front2,
                    winner: frontResult
                });

                let sweepBonus = '';
                if (player1Score === 3) {
                    player1Score += 3;
                    sweepBonus = 'player1';
                }
                if (player2Score === 3) {
                    player2Score += 3;
                    sweepBonus = 'player2';
                }

                return { player1Score, player2Score, details, sweepBonus };
            }

            showScoringPopup(detailedResults, roundScores, bonusPoints) {
                const popup = document.getElementById('scoringPopup');
                const allPlayerHands = document.getElementById('allPlayerHands');
                const roundRobinResults = document.getElementById('roundRobinResults');

                allPlayerHands.innerHTML = '';
                this.players.forEach(player => {
                    const hand = this.submittedHands.get(player.name);
                    const bonus = bonusPoints.get(player.name);
                    const headToHead = roundScores.get(player.name) - bonus;

                    if (hand) {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'player-hand-display';
                        playerDiv.innerHTML = `
                            <div class="player-hand-title">${player.name} - Round Score: +${roundScores.get(player.name)} points (Head-to-head: +${headToHead}, Bonus: +${bonus})</div>
                            <div class="hand-row">
                                <div class="hand-label-popup">Back:</div>
                                <div class="hand-cards">${this.renderMiniCards(hand.back)}</div>
                                <div class="hand-strength-popup">${this.getHandName(this.evaluateHand(hand.back))} (${this.evaluateHand(hand.back).hand_rank.join(', ')})${this.getBackBonus(this.evaluateHand(hand.back))}</div>
                            </div>
                            <div class="hand-row">
                                <div class="hand-label-popup">Middle:</div>
                                <div class="hand-cards">${this.renderMiniCards(hand.middle)}</div>
                                <div class="hand-strength-popup">${this.getHandName(this.evaluateHand(hand.middle))} (${this.evaluateHand(hand.middle).hand_rank.join(', ')})${this.getMiddleBonus(this.evaluateHand(hand.middle))}</div>
                            </div>
                            <div class="hand-row">
                                <div class="hand-label-popup">Front:</div>
                                <div class="hand-cards">${this.renderMiniCards(hand.front)}</div>
                                <div class="hand-strength-popup">${this.getThreeCardHandName(this.evaluateThreeCardHand(hand.front))} (${this.evaluateThreeCardHand(hand.front).hand_rank.join(', ')})${this.getFrontBonus(this.evaluateThreeCardHand(hand.front))}</div>
                            </div>
                        `;
                        allPlayerHands.appendChild(playerDiv);
                    }
                });

                roundRobinResults.innerHTML = '';
                detailedResults.forEach(result => {
                    const matchupDiv = document.createElement('div');
                    matchupDiv.className = 'matchup';

                    let matchupHTML = `
                        <div class="matchup-title">${result.player1} vs ${result.player2}</div>
                    `;

                    result.details.forEach(detail => {
                        const p1Class = detail.winner === 'player1' ? 'winner' : detail.winner === 'tie' ? 'tie' : 'loser';
                        const p2Class = detail.winner === 'player2' ? 'winner' : detail.winner === 'tie' ? 'tie' : 'loser';

                        matchupHTML += `
                            <div class="comparison-row">
                                <div class="player-result ${p1Class}">
                                    ${detail.player1Hand.name} (${detail.player1Hand.hand_rank.join(', ')})
                                </div>
                                <div style="color: #ffd700; font-weight: bold;">${detail.hand}</div>
                                <div class="player-result ${p2Class}">
                                    ${detail.player2Hand.name} (${detail.player2Hand.hand_rank.join(', ')})
                                </div>
                            </div>
                        `;
                    });

                    matchupHTML += `
                        <div class="comparison-row">
                            <div class="player-result ${result.player1Score > result.player2Score ? 'winner' : result.player1Score < result.player2Score ? 'loser' : 'tie'}">
                                ${result.player1}: ${result.player1Score} points
                            </div>
                            <div style="color: #ffd700; font-weight: bold;">HEAD-TO-HEAD</div>
                            <div class="player-result ${result.player2Score > result.player1Score ? 'winner' : result.player2Score < result.player1Score ? 'loser' : 'tie'}">
                                ${result.player2}: ${result.player2Score} points
                            </div>
                        </div>
                        ${result.sweepBonus ? `<div style="text-align: center; color: #4ecdc4; font-weight: bold; margin-top: 10px;">🎉 ${result.sweepBonus === 'player1' ? result.player1 : result.player2} wins all hands +3 bonus!</div>` : ''}
                    `;

                    matchupDiv.innerHTML = matchupHTML;
                    roundRobinResults.appendChild(matchupDiv);
                });

                popup.style.display = 'block';
            }

            getBackBonus(evaluation) {
                if (evaluation.hand_rank[0] === 10) return ' (+5 bonus)'; // Five of a Kind
                if (evaluation.hand_rank[0] === 8) return ' (+3 bonus)';  // Four of a Kind
                if (evaluation.hand_rank[0] === 9) return ' (+4 bonus)';  // Straight Flush
                return '';
            }

            getMiddleBonus(evaluation) {
                if (evaluation.hand_rank[0] === 10) return ' (+5 bonus)'; // Five of a Kind
                if (evaluation.hand_rank[0] === 7) return ' (+1 bonus)';  // Full House
                if (evaluation.hand_rank[0] === 8) return ' (+7 bonus)';  // Four of a Kind
                if (evaluation.hand_rank[0] === 9) return ' (+9 bonus)';  // Straight Flush
                return '';
            }

            getFrontBonus(evaluation) {
                // Check if this is a 3-card hand evaluation (no bonus for 3-card hands)
                if (evaluation.hand_rank.length <= 3) {
                    if (evaluation.hand_rank[0] === 4) return ' (+2 bonus)'; // Three of a kind in 3-card front
                    return '';
                }

                // 5-card front hand bonuses
                if (evaluation.hand_rank[0] === 10) return ' (+17 bonus)'; // Five of a Kind
                if (evaluation.hand_rank[0] === 9) return ' (+14 bonus)';  // Straight Flush
                if (evaluation.hand_rank[0] === 8) return ' (+11 bonus)';  // Four of a Kind
                if (evaluation.hand_rank[0] === 7) return ' (+4 bonus)';   // Full House
                if (evaluation.hand_rank[0] === 6) return ' (+3 bonus)';   // Flush
                if (evaluation.hand_rank[0] === 5) return ' (+3 bonus)';   // Straight
                return '';
            }

            renderMiniCards(cards) {
                return cards.map(card => {
                    if (card.isWild) {
                        return `<div class="card-mini wild">🃏</div>`;
                    } else {
                        const colorClass = ['♥', '♦'].includes(card.suit) ? 'red' : 'black';
                        return `<div class="card-mini ${colorClass}"><div>${card.rank}</div><div>${card.suit}</div></div>`;
                    }
                }).join('');
            }

            toggleSidebar() {
                this.sidebarVisible = !this.sidebarVisible;

                const sidebar = document.getElementById('sidebar');
                const gameArea = document.getElementById('gameArea');
                const toggleIcon = document.getElementById('toggleIcon');
                const toggleText = document.getElementById('toggleText');

                if (this.sidebarVisible) {
                    if (sidebar) {
                        sidebar.classList.remove('hidden');
                        sidebar.style.display = 'block';
                    }
                    if (gameArea) {
                        gameArea.classList.remove('sidebar-hidden');
                        gameArea.style.gridTemplateColumns = '1fr 320px';
                    }
                    if (toggleIcon) toggleIcon.textContent = '◀';
                    if (toggleText) toggleText.textContent = 'Hide';
                } else {
                    if (sidebar) {
                        sidebar.classList.add('hidden');
                        sidebar.style.display = 'none';
                    }
                    if (gameArea) {
                        gameArea.classList.add('sidebar-hidden');
                        gameArea.style.gridTemplateColumns = '1fr';
                    }
                    if (toggleIcon) toggleIcon.textContent = '▶';
                    if (toggleText) toggleText.textContent = 'Show';
                }
            }

            closeScoringPopup() {
                document.getElementById('scoringPopup').style.display = 'none';
            }

            updateDisplay() {
                this.updateStatus();
                this.updatePlayerList();
                this.updateScoring();
                this.updateButtonStates();
            }

            updateButtonStates() {
                const newGameBtn = document.getElementById('newGame');
                const addPlayerBtn = document.getElementById('addPlayer');
                const autoBtn = document.getElementById('autoArrange');
                const rankBtn = document.getElementById('sortByRank');
                const suitBtn = document.getElementById('sortBySuit');
                const submitBtn = document.getElementById('submitHand');

                if (this.gameState === 'waiting') {
                    addPlayerBtn.disabled = false;
                    newGameBtn.disabled = this.players.length < 2;
                    autoBtn.disabled = true;
                    rankBtn.disabled = true;
                    suitBtn.disabled = true;
                    submitBtn.disabled = true;
                } else if (this.gameState === 'playing') {
                    addPlayerBtn.disabled = true;
                    newGameBtn.disabled = false;
                    autoBtn.disabled = false;
                    rankBtn.disabled = false;
                    suitBtn.disabled = false;
                } else if (this.gameState === 'scoring') {
                    addPlayerBtn.disabled = false;
                    newGameBtn.disabled = false;
                    autoBtn.disabled = true;
                    rankBtn.disabled = true;
                    suitBtn.disabled = true;
                    submitBtn.disabled = true;
                }
            }

            updateStatus() {
                const status = document.getElementById('status');

                if (this.gameState === 'waiting') {
                    status.textContent = `Players: ${this.players.length}/4 - Add players and click "New Game" to start!`;
                } else if (this.gameState === 'playing') {
                    const currentPlayer = this.players[this.currentPlayerIndex];
                    const readyCount = this.players.filter(p => p.ready).length;
                    status.textContent = `${currentPlayer.name}'s turn - Arrange your cards! (${readyCount}/${this.players.length} players ready)`;
                } else if (this.gameState === 'scoring') {
                    status.textContent = 'Round complete! Check the scores below.';
                }
            }

            updatePlayerList() {
                const playerList = document.getElementById('playerList');
                playerList.innerHTML = '';

                this.players.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-item';

                    if (this.gameState === 'playing' && index === this.currentPlayerIndex) {
                        playerDiv.classList.add('current');
                    }
                    if (player.ready) {
                        playerDiv.classList.add('ready');
                    }

                    const score = this.scores.get(player.name) || 0;
                    playerDiv.innerHTML = `
                        <span>${player.name}</span>
                        <span>${player.ready ? '✓' : ''} ${score} pts</span>
                    `;

                    playerList.appendChild(playerDiv);
                });
            }

            updateScoring() {
                const scoring = document.getElementById('scoring');
                const scoreList = document.getElementById('scoreList');

                if (this.gameState === 'scoring' && this.scores.size > 0) {
                    scoring.style.display = 'block';
                    scoreList.innerHTML = '';

                    const sortedScores = [...this.scores.entries()].sort((a, b) => b[1] - a[1]);

                    sortedScores.forEach(([playerName, score]) => {
                        const scoreDiv = document.createElement('div');
                        scoreDiv.className = 'score-item';
                        scoreDiv.innerHTML = `
                            <span>${playerName}</span>
                            <span>${score} points</span>
                        `;
                        scoreList.appendChild(scoreDiv);
                    });
                } else {
                    scoring.style.display = 'none';
                }
            }
        }

        // Initialize the game when the page loads
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new ChinesePokerGame();
        });
    </script>
</body>
</html>